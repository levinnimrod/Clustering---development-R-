# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
View(typology)
typology
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
for (l in (seq(5))) {
for (i in seq(4, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 100)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 100)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(10))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 2)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 2)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 4)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 3)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 2)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 50)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 50)
#typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 25)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 25)
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
if (total_iteration[n_groups, sample] <= 3000) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 25)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 25)
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 1)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 1)
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
if (total_iteration[n_groups, sample] <= 3020) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 1)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 1)
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
if (total_iteration[n_groups, sample] <= 3100) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
}
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 1)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 1)
}
}
if (total_iteration[n_groups, sample] <= 5000) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
if (total_iteration[n_groups, sample] <= 5000) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
}
typology <- function(data, n_groups, sample, iterations) {
i = 1
#  setwd("C:\\Users\\owner\\Desktop\\Study 4\\Mclust outputs\\")
setwd('/Users/nimrodlevin/Desktop/Study 4/Mclust outputs')
# Get the optimal log-likelihood and total iterations so far
ll <- read.csv('optimal loglikelihood')[,-1]
total_iteration = read.csv('total iterations')[-1]
if (total_iteration[n_groups, sample] <= 5000) {
# to control for a new optimal result
new = 0
# run mclust to check for better solutions
for (i in seq(iterations)) {
print(paste0("Iteration #", i + total_iteration[n_groups, sample], " for sample #", sample, ' and groups = ', n_groups))
i = i + 1
#  mclust.options(subset = 600)
result <- Mclust(data, G = n_groups, modelNames = 'EII')
if (result$loglik >= ll[n_groups, sample]) {
# compute the difference for the new best ll compared to previous
ll[n_groups, sample + 6] = ll[n_groups, sample + 2]
ll[n_groups, sample + 2] = i + total_iteration[n_groups, sample] - 1
ll[n_groups, sample + 4] = (result$loglik-ll[n_groups, sample]) %>% round(2)
ll[n_groups, sample + 8] = result$modelName
ll[n_groups, sample + 10] = result$df
# save the new best results
best = result
ll[n_groups, sample] <- result$loglik %>% round(2) # update ll value in table
print(c("A new ll maximum = ", ll[n_groups, sample] %>% round(2)))
# Save new best results
best_save <- best$z %>% as.data.frame(); best_save <- cbind(best_save, best$classification)
new = 1
print(summary(best))
}
}
# save new data for optimal ll + total iterations
write.csv(ll, file = 'optimal loglikelihood')
total_iteration[n_groups, sample] = total_iteration[n_groups, sample] + i - 1
write.csv(total_iteration, file = 'total iterations')
# save the results only if there is a new optimal result
if (new == 1) {
write.csv(best_save, file = paste0('Clustering results/z and classificaiton for sample ', sample, ' with groups ', n_groups))
}
}
}
####################      RUN MIXTURE MODEL CLUSTERING                ####################
# create ipsative scores for each participant
ipsative1 <- sample1[, 7:16]  %>% round(2) %>% as.data.frame()
ipsative2 <- sample2[, 7:16]  %>% round(2) %>% as.data.frame()
for (l in (seq(100))) {
for (i in seq(2, 5)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 10)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 10)
}
}
####################      RUN MIXTURE MODEL CLUSTERING                ####################
# create ipsative scores for each participant
ipsative1 <- sample1[, 7:16] %>% t %>% scale %>% t %>% round(2) %>% as.data.frame()
ipsative2 <- sample2[, 7:16] %>% t %>% scale %>% t %>% round(2) %>% as.data.frame()
# get best estimate of loglikelihood from previous iteration
url <- file.choose(); source(url); remove(url)
for (l in (seq(100))) {
for (i in seq(2, 10)) {
typology(data = ipsative1, n_groups = i, sample = 1, iterations = 20)
typology(data = ipsative2, n_groups = i, sample = 2, iterations = 20)
}
}
